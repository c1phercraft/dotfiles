#
# Bash custom prompt.
#

# If not running interactively, don't do anything
[[ "$-" != *i* ]] && return

# Foreground.
readonly FG_BLACK="$(tput setaf 0)"
readonly FG_RED="$(tput setaf 1)"
readonly FG_GREEN="$(tput setaf 2)"
readonly FG_BROWN="$(tput setaf 3)"
readonly FG_BLUE="$(tput setaf 4)"
readonly FG_PURPLE="$(tput setaf 5)"
readonly FG_CYAN="$(tput setaf 6)"
readonly FG_DARKGRAY="$(tput setaf 7)"

# Bright foreground.
readonly FG_GRAY_BRIGHT="$(tput setaf 8)"
readonly FG_RED_BRIGHT="$(tput setaf 9)"
readonly FG_GREEN_BRIGHT="$(tput setaf 10)"
readonly FG_BROWN_BRIGHT="$(tput setaf 11)"
readonly FG_BLUE_BRIGHT="$(tput setaf 12)"
readonly FG_PURPLE_BRIGHT="$(tput setaf 13)"
readonly FG_CYAN_BRIGHT="$(tput setaf 14)"
readonly FG_WHITE="$(tput setaf 15)"

# Background.
readonly BG_BLACK="$(tput setab 0)"
readonly BG_RED="$(tput setab 1)"
readonly BG_GREEN="$(tput setab 2)"
readonly BG_BROWN="$(tput setab 3)"
readonly BG_BLUE="$(tput setab 4)"
readonly BG_PURPLE="$(tput setab 5)"
readonly BG_CYAN="$(tput setab 6)"
readonly BG_DARKGRAY="$(tput setab 7)"

# Bright background.
readonly BG_BLACK_BRIGHT="$(tput setab 8)"
readonly BG_RED_BRIGHT="$(tput setab 9)"
readonly BG_GREEN_BRIGHT="$(tput setab 10)"
readonly BG_BROWN_BRIGHT="$(tput setab 11)"
readonly BG_BLUE_BRIGHT="$(tput setab 12)"
readonly BG_PURPLE_BRIGHT="$(tput setab 13)"
readonly BG_CYAN_BRIGHT="$(tput setab 14)"
readonly BG_DARKGRAY_BRIGHT="$(tput setab 15)"

readonly BOLD="$(tput bold)"
readonly ITALIC="$(tput sitm)"
readonly UNDERLINE="$(tput smul)"
readonly NC="$(tput sgr0)"  # No color.

# Set a fancy prompt (non-color, unless we know we "want" color)
color_prompt=
case "$TERM" in
  xterm-color) color_prompt=yes;;
  xterm) color_prompt=yes;;
esac

if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
  # We have color support; assume it's compliant with Ecma-48
  # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
  # a case would tend to support setf rather than setaf.)
  color_prompt=yes
fi

echo_right() {
  local line=$1
  columns="$(tput cols)"
  printf "%*s" $columns "$line"
}

START_CAP=
END_CAP=

update_prompt() {
  local LAST_RESULT=$?
  
  # Day and time.
  PS1="\n\[$FG_DARKGRAY\]$START_CAP\[$NC$FG_BLACK$BG_DARKGRAY\]\D{%d}\[$NC$FG_DARKGRAY\]$END_CAP"
  PS1+="\[$FG_BLUE\]$START_CAP\[$FG_BLACK$BG_BLUE\]\D{%H%M}\[$NC$FG_BLUE\]$END_CAP"
  # Number of jobs.
  PS1+="\[$FG_DARKGRAY\]$START_CAP\[$FG_BLACK$BG_DARKGRAY\]\j\[$NC$FG_DARKGRAY\]$END_CAP"
  # User and host.
  PS1+="\[$FG_BLUE\]$START_CAP\[$FG_BLACK$BG_BLUE\]\u@\h\[$NC$FG_BLUE\]$END_CAP"
  # Current working directory.
  PS1+="\[$FG_BROWN\]$START_CAP\[$FG_BLACK$BG_BROWN\]\w\[$NC$FG_BROWN\]$END_CAP"
  
  if `git rev-parse --is-inside-work-tree 2> /dev/null`; then
    # Inside a Git repo, so add more information.

    local ICON_AHEAD='⇡'
    local ICON_BEHIND='⇣'
    local ICON_UNSTAGED='↥'
    local ICON_STAGED='⤒'
    local ICON_MERGING='ᛣ'
    local ICON_REBASING='⇈'

    local FG_GIT=$FG_GREEN
    local BG_GIT=$BG_GREEN
    local FLAGS=
    local NUM_AHEAD="$(git log --oneline @{u}.. 2> /dev/null | wc -l | tr -d ' ')"
    if [ $NUM_AHEAD -gt 0 ]; then
      # Commits that are not pushed to remote yet.
      FLAGS+=" $ICON_AHEAD$NUM_AHEAD"
      FG_GIT=$FG_CYAN
      BG_GIT=$BG_CYAN
    fi
    local NUM_BEHIND="$(git log --oneline ..@{u} 2> /dev/null | wc -l | tr -d ' ')"
    if [ $NUM_BEHIND -gt 0 ]; then
      # Commits on remote that have not been pulled yet.
      FLAGS+=" $ICON_BEHIND$NUM_BEHIND"
      FG_GIT=$FG_CYAN
      BG_GIT=$BG_CYAN
    fi
    
    local GIT_DIR="$(git rev-parse --git-dir 2> /dev/null)"
    if ! git diff --quiet 2> /dev/null; then
      # Unstaged changes.
      FLAGS+=" $ICON_UNSTAGED"
      FG_GIT=$FG_CYAN
      BG_GIT=$BG_CYAN
    fi
    if ! git diff --cached --quiet 2> /dev/null; then
      # Staged changes.
      FLAGS+=" $ICON_STAGED"
      FG_GIT=$FG_CYAN
      BG_GIT=$BG_CYAN
    fi
    if git rebase --show-current-patch 2> /dev/null; then
      # Rebase on-going.
      FLAGS+=" $ICON_REBASING"
      FG_GIT=$FG_RED
      BG_GIT=$BG_RED
    fi
    if [ -n $GIT_DIR ] && test -r $GIT_DIR/MERGE_HEAD; then
      # In the middle of a merge.
      FLAGS+=" $ICON_MERGING"
      FG_GIT=$FG_RED
      BG_GIT=$BG_RED
    fi
    
    # Git branch.
    local BRANCH="$(git rev-parse --abbrev-ref HEAD 2> /dev/null)"
    PS1+="\[$NC$FG_GIT\]$START_CAP\[$FG_WHITE$BG_GIT\] \[$ITALIC\]$BRANCH\[$NC\]"

    # Add flags.
    if [ "$FLAGS" != "" ]; then
        PS1+="\[$FG_WHITE$BG_GIT\]$FLAGS \[$NC$FG_GIT\]$END_CAP"
    else
        PS1+="\[$NC$FG_GIT\]$END_CAP"
    fi

    # Terminal title shows current repo.
    local ROOT_PATH="$(git rev-parse --show-toplevel 2> /dev/null)"
    ROOT_PATH=$(basename $ROOT_PATH)
    set_title $ROOT_PATH
  else
    set_title "Terminal"
  fi
  
  # Actual prompt.
  PS1+="$NC\n"
  if [ $LAST_RESULT == 0 ]; then
    PS1+="\[$FG_GREEN\]:o)"
  else
    PS1+="\[$FG_RED\]:o("
  fi
  PS1+="\[$FG_GRAY_BRIGHT\]\$\[$NC\] "
}

if [ "$color_prompt" = "yes" ]; then
  shopt -u promptvars
  PROMPT_COMMAND=update_prompt
else
  PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi

#PROMPT_DIRTRIM=5
unset color_prompt

